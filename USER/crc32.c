#include "crc32.h"

////////////////////////// for little packet crc check/////////////////////////////////////////////////////////////
/*!
 *  \fn     CalcCrc32
 *
 *  \brief  Calculate the CRC-32 of the given buffer.
 *
 *  \param  crcInit  Initial value of the CRC.
 *  \param  len      Length of the buffer.
 *  \param  pBuf     Buffer to compute the CRC.
 *
 *  \return None.
 *
 *  This routine was originally generated with crcmod.py using the following parameters:
 *    - polynomial 0x104C11DB7
 *    - bit reverse algorithm
 */
/*************************************************************************************************/

static const uint32_t crc32Table[256] =
{
  0x00000000U, 0x77073096U, 0xEE0E612CU, 0x990951BAU,
  0x076DC419U, 0x706AF48FU, 0xE963A535U, 0x9E6495A3U,
  0x0EDB8832U, 0x79DCB8A4U, 0xE0D5E91EU, 0x97D2D988U,
  0x09B64C2BU, 0x7EB17CBDU, 0xE7B82D07U, 0x90BF1D91U,
  0x1DB71064U, 0x6AB020F2U, 0xF3B97148U, 0x84BE41DEU,
  0x1ADAD47DU, 0x6DDDE4EBU, 0xF4D4B551U, 0x83D385C7U,
  0x136C9856U, 0x646BA8C0U, 0xFD62F97AU, 0x8A65C9ECU,
  0x14015C4FU, 0x63066CD9U, 0xFA0F3D63U, 0x8D080DF5U,
  0x3B6E20C8U, 0x4C69105EU, 0xD56041E4U, 0xA2677172U,
  0x3C03E4D1U, 0x4B04D447U, 0xD20D85FDU, 0xA50AB56BU,
  0x35B5A8FAU, 0x42B2986CU, 0xDBBBC9D6U, 0xACBCF940U,
  0x32D86CE3U, 0x45DF5C75U, 0xDCD60DCFU, 0xABD13D59U,
  0x26D930ACU, 0x51DE003AU, 0xC8D75180U, 0xBFD06116U,
  0x21B4F4B5U, 0x56B3C423U, 0xCFBA9599U, 0xB8BDA50FU,
  0x2802B89EU, 0x5F058808U, 0xC60CD9B2U, 0xB10BE924U,
  0x2F6F7C87U, 0x58684C11U, 0xC1611DABU, 0xB6662D3DU,
  0x76DC4190U, 0x01DB7106U, 0x98D220BCU, 0xEFD5102AU,
  0x71B18589U, 0x06B6B51FU, 0x9FBFE4A5U, 0xE8B8D433U,
  0x7807C9A2U, 0x0F00F934U, 0x9609A88EU, 0xE10E9818U,
  0x7F6A0DBBU, 0x086D3D2DU, 0x91646C97U, 0xE6635C01U,
  0x6B6B51F4U, 0x1C6C6162U, 0x856530D8U, 0xF262004EU,
  0x6C0695EDU, 0x1B01A57BU, 0x8208F4C1U, 0xF50FC457U,
  0x65B0D9C6U, 0x12B7E950U, 0x8BBEB8EAU, 0xFCB9887CU,
  0x62DD1DDFU, 0x15DA2D49U, 0x8CD37CF3U, 0xFBD44C65U,
  0x4DB26158U, 0x3AB551CEU, 0xA3BC0074U, 0xD4BB30E2U,
  0x4ADFA541U, 0x3DD895D7U, 0xA4D1C46DU, 0xD3D6F4FBU,
  0x4369E96AU, 0x346ED9FCU, 0xAD678846U, 0xDA60B8D0U,
  0x44042D73U, 0x33031DE5U, 0xAA0A4C5FU, 0xDD0D7CC9U,
  0x5005713CU, 0x270241AAU, 0xBE0B1010U, 0xC90C2086U,
  0x5768B525U, 0x206F85B3U, 0xB966D409U, 0xCE61E49FU,
  0x5EDEF90EU, 0x29D9C998U, 0xB0D09822U, 0xC7D7A8B4U,
  0x59B33D17U, 0x2EB40D81U, 0xB7BD5C3BU, 0xC0BA6CADU,
  0xEDB88320U, 0x9ABFB3B6U, 0x03B6E20CU, 0x74B1D29AU,
  0xEAD54739U, 0x9DD277AFU, 0x04DB2615U, 0x73DC1683U,
  0xE3630B12U, 0x94643B84U, 0x0D6D6A3EU, 0x7A6A5AA8U,
  0xE40ECF0BU, 0x9309FF9DU, 0x0A00AE27U, 0x7D079EB1U,
  0xF00F9344U, 0x8708A3D2U, 0x1E01F268U, 0x6906C2FEU,
  0xF762575DU, 0x806567CBU, 0x196C3671U, 0x6E6B06E7U,
  0xFED41B76U, 0x89D32BE0U, 0x10DA7A5AU, 0x67DD4ACCU,
  0xF9B9DF6FU, 0x8EBEEFF9U, 0x17B7BE43U, 0x60B08ED5U,
  0xD6D6A3E8U, 0xA1D1937EU, 0x38D8C2C4U, 0x4FDFF252U,
  0xD1BB67F1U, 0xA6BC5767U, 0x3FB506DDU, 0x48B2364BU,
  0xD80D2BDAU, 0xAF0A1B4CU, 0x36034AF6U, 0x41047A60U,
  0xDF60EFC3U, 0xA867DF55U, 0x316E8EEFU, 0x4669BE79U,
  0xCB61B38CU, 0xBC66831AU, 0x256FD2A0U, 0x5268E236U,
  0xCC0C7795U, 0xBB0B4703U, 0x220216B9U, 0x5505262FU,
  0xC5BA3BBEU, 0xB2BD0B28U, 0x2BB45A92U, 0x5CB36A04U,
  0xC2D7FFA7U, 0xB5D0CF31U, 0x2CD99E8BU, 0x5BDEAE1DU,
  0x9B64C2B0U, 0xEC63F226U, 0x756AA39CU, 0x026D930AU,
  0x9C0906A9U, 0xEB0E363FU, 0x72076785U, 0x05005713U,
  0x95BF4A82U, 0xE2B87A14U, 0x7BB12BAEU, 0x0CB61B38U,
  0x92D28E9BU, 0xE5D5BE0DU, 0x7CDCEFB7U, 0x0BDBDF21U,
  0x86D3D2D4U, 0xF1D4E242U, 0x68DDB3F8U, 0x1FDA836EU,
  0x81BE16CDU, 0xF6B9265BU, 0x6FB077E1U, 0x18B74777U,
  0x88085AE6U, 0xFF0F6A70U, 0x66063BCAU, 0x11010B5CU,
  0x8F659EFFU, 0xF862AE69U, 0x616BFFD3U, 0x166CCF45U,
  0xA00AE278U, 0xD70DD2EEU, 0x4E048354U, 0x3903B3C2U,
  0xA7672661U, 0xD06016F7U, 0x4969474DU, 0x3E6E77DBU,
  0xAED16A4AU, 0xD9D65ADCU, 0x40DF0B66U, 0x37D83BF0U,
  0xA9BCAE53U, 0xDEBB9EC5U, 0x47B2CF7FU, 0x30B5FFE9U,
  0xBDBDF21CU, 0xCABAC28AU, 0x53B39330U, 0x24B4A3A6U,
  0xBAD03605U, 0xCDD70693U, 0x54DE5729U, 0x23D967BFU,
  0xB3667A2EU, 0xC4614AB8U, 0x5D681B02U, 0x2A6F2B94U,
  0xB40BBE37U, 0xC30C8EA1U, 0x5A05DF1BU, 0x2D02EF8DU
};


uint32_t CalcCrc32(uint32_t crcInit, uint32_t len, uint8_t *pBuf)
{
  uint32_t crc = crcInit;

  while (len > 0)
  {
    crc = crc32Table[*pBuf ^ (uint8_t)crc] ^ (crc >> 8);
    pBuf++;
    len--;
  }

  crc = crc ^ 0xFFFFFFFFU;

  return crc;
}
////////////////////////// for little packet crc check/////////////////////////////////////////////////////////////


////////////////////////// for the whole firmware crc check////////////////////////////////////////////////////////
//*****************************************************************************
//
// CRC-32 table
// Polynomial = 0x1EDC6F41 (also listed as CRC-32C or CRC-32/4)
//
// This polynomial should catch all errors up to 4 bits for image sizes under
// about 255MB (which easily covers anything we can actually fit in flash), and
// it has a reasonably high probablility of catching bigger errors.
//
// See http://users.ece.cmu.edu/~koopman/crc for more information.
//
//*****************************************************************************

#define CRC32_POLYNOMIAL          0x1EDC6F41
const static uint32_t g_pui32CRC32Table[256] =
{
	0x00000000, 0x1EDC6F41, 0x3DB8DE82, 0x2364B1C3,
	0x7B71BD04, 0x65ADD245, 0x46C96386, 0x58150CC7,
	0xF6E37A08, 0xE83F1549, 0xCB5BA48A, 0xD587CBCB,
	0x8D92C70C, 0x934EA84D, 0xB02A198E, 0xAEF676CF,
	0xF31A9B51, 0xEDC6F410, 0xCEA245D3, 0xD07E2A92,
	0x886B2655, 0x96B74914, 0xB5D3F8D7, 0xAB0F9796,
	0x05F9E159, 0x1B258E18, 0x38413FDB, 0x269D509A,
	0x7E885C5D, 0x6054331C, 0x433082DF, 0x5DECED9E,
	0xF8E959E3, 0xE63536A2, 0xC5518761, 0xDB8DE820,
	0x8398E4E7, 0x9D448BA6, 0xBE203A65, 0xA0FC5524,
	0x0E0A23EB, 0x10D64CAA, 0x33B2FD69, 0x2D6E9228,
	0x757B9EEF, 0x6BA7F1AE, 0x48C3406D, 0x561F2F2C,
	0x0BF3C2B2, 0x152FADF3, 0x364B1C30, 0x28977371,
	0x70827FB6, 0x6E5E10F7, 0x4D3AA134, 0x53E6CE75,
	0xFD10B8BA, 0xE3CCD7FB, 0xC0A86638, 0xDE740979,
	0x866105BE, 0x98BD6AFF, 0xBBD9DB3C, 0xA505B47D,
	0xEF0EDC87, 0xF1D2B3C6, 0xD2B60205, 0xCC6A6D44,
	0x947F6183, 0x8AA30EC2, 0xA9C7BF01, 0xB71BD040,
	0x19EDA68F, 0x0731C9CE, 0x2455780D, 0x3A89174C,
	0x629C1B8B, 0x7C4074CA, 0x5F24C509, 0x41F8AA48,
	0x1C1447D6, 0x02C82897, 0x21AC9954, 0x3F70F615,
	0x6765FAD2, 0x79B99593, 0x5ADD2450, 0x44014B11,
	0xEAF73DDE, 0xF42B529F, 0xD74FE35C, 0xC9938C1D,
	0x918680DA, 0x8F5AEF9B, 0xAC3E5E58, 0xB2E23119,
	0x17E78564, 0x093BEA25, 0x2A5F5BE6, 0x348334A7,
	0x6C963860, 0x724A5721, 0x512EE6E2, 0x4FF289A3,
	0xE104FF6C, 0xFFD8902D, 0xDCBC21EE, 0xC2604EAF,
	0x9A754268, 0x84A92D29, 0xA7CD9CEA, 0xB911F3AB,
	0xE4FD1E35, 0xFA217174, 0xD945C0B7, 0xC799AFF6,
	0x9F8CA331, 0x8150CC70, 0xA2347DB3, 0xBCE812F2,
	0x121E643D, 0x0CC20B7C, 0x2FA6BABF, 0x317AD5FE,
	0x696FD939, 0x77B3B678, 0x54D707BB, 0x4A0B68FA,
	0xC0C1D64F, 0xDE1DB90E, 0xFD7908CD, 0xE3A5678C,
	0xBBB06B4B, 0xA56C040A, 0x8608B5C9, 0x98D4DA88,
	0x3622AC47, 0x28FEC306, 0x0B9A72C5, 0x15461D84,
	0x4D531143, 0x538F7E02, 0x70EBCFC1, 0x6E37A080,
	0x33DB4D1E, 0x2D07225F, 0x0E63939C, 0x10BFFCDD,
	0x48AAF01A, 0x56769F5B, 0x75122E98, 0x6BCE41D9,
	0xC5383716, 0xDBE45857, 0xF880E994, 0xE65C86D5,
	0xBE498A12, 0xA095E553, 0x83F15490, 0x9D2D3BD1,
	0x38288FAC, 0x26F4E0ED, 0x0590512E, 0x1B4C3E6F,
	0x435932A8, 0x5D855DE9, 0x7EE1EC2A, 0x603D836B,
	0xCECBF5A4, 0xD0179AE5, 0xF3732B26, 0xEDAF4467,
	0xB5BA48A0, 0xAB6627E1, 0x88029622, 0x96DEF963,
	0xCB3214FD, 0xD5EE7BBC, 0xF68ACA7F, 0xE856A53E,
	0xB043A9F9, 0xAE9FC6B8, 0x8DFB777B, 0x9327183A,
	0x3DD16EF5, 0x230D01B4, 0x0069B077, 0x1EB5DF36,
	0x46A0D3F1, 0x587CBCB0, 0x7B180D73, 0x65C46232,
	0x2FCF0AC8, 0x31136589, 0x1277D44A, 0x0CABBB0B,
	0x54BEB7CC, 0x4A62D88D, 0x6906694E, 0x77DA060F,
	0xD92C70C0, 0xC7F01F81, 0xE494AE42, 0xFA48C103,
	0xA25DCDC4, 0xBC81A285, 0x9FE51346, 0x81397C07,
	0xDCD59199, 0xC209FED8, 0xE16D4F1B, 0xFFB1205A,
	0xA7A42C9D, 0xB97843DC, 0x9A1CF21F, 0x84C09D5E,
	0x2A36EB91, 0x34EA84D0, 0x178E3513, 0x09525A52,
	0x51475695, 0x4F9B39D4, 0x6CFF8817, 0x7223E756,
	0xD726532B, 0xC9FA3C6A, 0xEA9E8DA9, 0xF442E2E8,
	0xAC57EE2F, 0xB28B816E, 0x91EF30AD, 0x8F335FEC,
	0x21C52923, 0x3F194662, 0x1C7DF7A1, 0x02A198E0,
	0x5AB49427, 0x4468FB66, 0x670C4AA5, 0x79D025E4,
	0x243CC87A, 0x3AE0A73B, 0x198416F8, 0x075879B9,
	0x5F4D757E, 0x41911A3F, 0x62F5ABFC, 0x7C29C4BD,
	0xD2DFB272, 0xCC03DD33, 0xEF676CF0, 0xF1BB03B1,
	0xA9AE0F76, 0xB7726037, 0x9416D1F4, 0x8ACABEB5
};

//*****************************************************************************
//
//! @brief CRC-32 implementation allowing multiple partial images.
//!
//! @param pvData - Pointer to the data to be checked.
//! @param ui32NumBytes - Number of bytes to check.
//! @param pui32CRC - Location to store the partial CRC32 result.
//!
//! This function performs a CRC-32 on the input data and returns the 32-bit
//! result. This version uses a 256-entry lookup table to speed up the
//! computation of the result. The result of the CRC32 is stored in the
//! location given by the caller. This allows the caller to keep a "running"
//! CRC for individual chunks of an image.
//!
//! @return 32-bit CRC value.
//
//*****************************************************************************
void pace_ota_partial_crc32(const void *pvData, uint32_t ui32NumBytes, uint32_t *pui32CRC)
{
	uint32_t ui32CRCIndex, i;
	uint8_t *pui8Data;

	uint32_t ui32TempCRC = *pui32CRC;

	pui8Data = (uint8_t *) pvData;

	for ( i = 0; i < ui32NumBytes; i++ )
	{
		ui32CRCIndex = pui8Data[i] ^ (ui32TempCRC >> 24);
		ui32TempCRC = (ui32TempCRC << 8) ^ g_pui32CRC32Table[ui32CRCIndex];	
	}
	*pui32CRC = ui32TempCRC;
}


#if 0   /* DM: java reference code */
public static int calCrcBigData(byte[] datas) {
    int rem = 0;
    for (int i = 0; i < datas.length; i++) {
        rem = rem ^ (datas[i] << 24);
        for (int j = 0; j < 8; j++) {
            if ((rem & 0x80000000) == 0x80000000) {
                rem = (rem << 1) ^ CN;
            } else {
                rem = (rem << 1);
            }
        }
        rem = rem & 0xFFFFFFFF;
    }
    return rem;
}
#endif
////////////////////////// for the whole firmware crc check////////////////////////////////////////////////////////


